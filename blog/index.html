<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
      integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap"
      rel="stylesheet"
    />

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
      integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
      crossorigin="anonymous"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
      integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body);"
    ></script>

    <link href="highlight.css" rel="stylesheet" />
  </head>
  <body>
    <main>
      <article style="width: 800px; margin: 0 auto">
        <div>
          <h1>Prolog from scratch</h1>
          <p>
            If you've ever wondered how Prolog works under the hood, you'll find
            out that it's actually not that complicated. (And yes, this includes
            cuts as well)
          </p>
        </div>
        <div>
          <h2>Prolog crash-course</h2>
          <p>
            If you're already familiar with Prolog you can skip this section.
            This is a 2-minute Prolog 101 which will cover just the basics. If
            you're still interested afterwards, I suggest looking up some more
            in-depth tutorials afterwards.
          </p>
          <p>
            There is a Github repo to go with this tutorial which you can check
            out here. Each code sample that I give here also contains a link to
            the commit.
          </p>
          <p>
            So let's have a look what Prolog is all about and what makes it
            special. Prolog is a logical and declarative programming language.
            You are probably already familiar with declarative languages like
            SQL, in which you typically specify what you want and you let the
            language figure out how to give it to you. Logic programming
            languages are closely related to mathematical logic. In the case of
            Prolog, it is based on what is called First-Order (or Predicate)
            logic. At its core, Prolog is just database of facts expressed in
            First-Order logic which can be queried. That is, we can ask Prolog
            if something is true given some facts. Let's see some simple
            examples:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">database.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
parent(george, elizabeth).
parent(george, margaret).
parent(elizabeth, charles).
parent(philip, charles).
parent(elizabeth, edward).
parent(philip, edward).
              </code></pre>
            </div>
          </div>
          <p>
            This is a simple Prolog program - we have 6 facts describing a
            predicate called 'parent'. The arguments are Prolog constants (in
            the language of logic, atoms). Anything that starts with a lowercase
            letter is treated as a constant in Prolog.
          </p>
          <p>Now we can take this program and ask questions about it:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- parent(george, elizabeth).
true.

?- parent(margaret, elizabeth).
false.
              </code></pre>
            </div>
          </div>
          <p>
            First, we asked if 'george' is a parent of 'elizabeth' and Prolog
            returned 'true'. Next, we asked whether 'parent(margaret,
            elizabeth)' and Prolog returned 'false'. To answer these queries,
            Prolog simply checks if the query exists in the program. This on its
            own is not that useful, so let's what else we can do:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- parent(george, X).
X = elizabeth.
X = margaret.

?- parent(X, Y).
X = george, Y = elizabeth.
X = george, Y = margaret.
X = elizabeth, Y = charles.
X = george, Y = charles.
X = elizabeth, Y = edward.
X = philip, Y = edward.
              </code></pre>
            </div>
          </div>
          <p>
            So what happened here? Rather than asking Prolog if some fact is in
            the database, we can ask for all results that match our query by
            using variables. (Prolog considers anything that starts with an
            upercase letter to be a variable) When Prolog sees that the query
            has a variable, it tries to find all assignments that satisfy the
            query.
          </p>
          <p>
            For now, we've only worked with simple facts, but Prolog also
            includes 'conditionals', in the language of logic, clauses. Let's
            use a clause to implement an 'ancestor' predicate:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
              </code></pre>
            </div>
          </div>
          <p>
            A Prolog clause is basically an implication. The above reads as: IF
            (parent(X, Z) AND ancestor(Z, Y)) THEN ancestor(X, Y). Basically,
            you have to read it backwards. Let's have a look:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- ancestor(george, elizabeth).
true.

?- ancestor(george, charles).
true.
              </code></pre>
            </div>
          </div>
          <p>We can of course ask for all ancestors of a person, e.g.:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- ancestor(X, charles).
X = elizabeth.
X = philip.
X = george.
X = edward.
              </code></pre>
            </div>
          </div>
          <p>
            And here lies the power of Prolog. Just by merely defining the
            'ancestor' predicate, we can not only ask if someone is someone
            else's ancestor but we can also ask Prolog to generate all ancestors
            according to the rules that we gave it. The only difference is that
            we use variables instead of constants, which is pretty neat. Imagine
            trying to implement this in another language.
          </p>
          <p>
            Prolog being closely related to First-Order logic has support for
            functions as well. Functions in Prolog, as in First-Order logic, are
            purely syntactic in nature (also called uninterpreted functions).
            They are used to build structure and to form compound terms from
            simple terms. In fact, Prolog does not have any built-in data
            structures to speak of. But it doesn't need them. We can implement
            everything just with functions. Here's an example of a linked list:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
X = c(1, c(2, c(3, c()))).
              </code></pre>
            </div>
          </div>
          <p>
            In a more standard notation, this list might be written as '[1,2,3]'
            (Swipl Prolog does actually have lists but they are syntactic
            sugar). What we've done is we've taken a function 'c' which stands
            for concatenate and defined a list as follows: 'c()' is an empty
            list. 'c(X, Y)' is a list where X is the first element and Y is the
            rest of the list. We can even write a Prolog predicate to tell us if
            something is a list according to our definition:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
list(c()).
list(c(Head, Tail)) :- list(Tail).
              </code></pre>
            </div>
          </div>
          <p>
            This definition basically says that an empty list (denoted as the
            argument-less function `list()`) is a list. Then, we recursively
            define a list as any list function with a head and a tail which is
            again a list. This kind of a linked list is similar to how lists are
            used in Lisp.
          </p>
          <p>We can also define operations on lists such as the length:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
last(c(Last, c()), Last).
last(c(Head, Tail), Last) :- last(Tail, Last).
              </code></pre>
            </div>
          </div>
          <p>
            (We assume that we have previously defined the 'increment' predicate
            which just increments by one)
          </p>
          <p>
            This concludes our Prolog crash-course. To summarize, in Prolog you
            define predicates which can either be simple facts like
            'parent(george, elizabeth)' or clauses which can be thought of as
            logical implications. When given a query, Prolog will try to find a
            variable assignment that satisfies all clauses.
          </p>
        </div>
        <div>
          <h2>Connection to First-Order logic</h2>
          <p>
            Prolog is essentially just a restricted form of First-Order
            resolution. The resolution algorithm allows us to answers questions
            like given a set of clauses S, and a formula q, does S => q? This is
            in general NP-Hard, but Prolog imposes a restriction that all
            clauses are Horn clauses, that is, the head contains only a single
            predicate. This makes it possible to systemcatically search
            resulting tree and the complexity becomes linear.
          </p>
        </div>
        <div>
          <h2>Getting our hands dirty</h2>
          <p>
            This is the part where we actually start implementing our own
            verions of Prolog. If you skipped the tutorial, you can start
            reading from here.
          </p>
          <p>
            We'll be using Python version >=3.10 since it includes structural
            pattern matching which will come in handy as we shall see later.
          </p>
          <p>
            Let's start by defining the basic elements of First-Order logic
            which are used by Prolog:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Term(Symbol):
    """Base class for atoms & variables"""


class Atom(Term):
    """A constant term, e.g., `c`"""

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class Function(Term):
    """A function term, e.g., `f(c)`"""

    def __init__(self, name, args: list[Term]):
        self.name = name
        self.arity = len(args)
        self.args = args

    def __repr__(self):
        args = ', '.join([repr(arg) for arg in self.args])
        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <p>
            We added the dunder 'repr' to have a nice print output. Let's try it
            out:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Atom('c')
'c'
>>> Function('f', args=[Atom('a')])
'f(a)'
>>> Function('f', args=[Atom('a'), Function('g', args=[Atom('b')])])
'f(a, g(b))'
              </code></pre>
            </div>
          </div>
          <p>Let's also add variables..</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
...

+class Variable(Term):
+    """A variable, e.g., `X` which takes on values of other terms"""
+
+    def __init__(self, name):
+        self.name = name
+
+    def __repr__(self):
+        return self.name
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Variable('X')
'X'
>>> Function('f', args=[Variable('X')])
'f(X)'
              </code></pre>
            </div>
          </div>
          <p>..and predicates</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
+class Symbol:
+    """Base class for terms and predicates"""

-class Term:
+class Term(Symbol):
    """Base class for atoms, functions & variables"""
...
+class Predicate(Symbol):
+    """A predicate, e.g., `P(X, f(Y))`. Predicates can be assigned truth values."""
+
+    def __init__(self, name, args: list[Term]):
+        self.name = name
+        self.arity = len(args)
+        self.args = args
+
+    def __repr__(self):
+        args = ', '.join([repr(arg) for arg in self.args])
+        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Predicate('P', args=[Variable('X'), Atom('x')])
'P(X, c)'
>>> Predicate('P', args=[Function('f', args=[Variable('X')])])
'P(f(X))'
              </code></pre>
            </div>
          </div>
          <p>
            We will now define some operations that can act on these objects. As
            we will see, the core of Prolog relies on just two operations -
            substitution and unification.
          </p>
        </div>
        <div>
          <h2>Substitution</h2>
          <p>
            Substitution in Prolog works the same way as in First-Order logic.
            When we have term, we might want to replace all occurences of a
            variable with the value of that variable. This is called a
            substitution. Let's see a simple example:
          </p>
          <div class="latex">S = \{ X \leftarrow c, Y \leftarrow f(b) \}</div>
          <div class="latex">P(X, Y, Z)</div>
          <p>
            Here, \(S\) is a set of variable assignments and \(P\) is our
            predicate in which we want to substitute varibles from \(S\). This
            is the result of the substitution:
          </p>
          <div class="latex">P(c, f(b), Z)</div>
          <p>
            \(X\) and \(Y\) are present in \(S\) and thus get substituted. \(Z\)
            is not a member of \(S\) and thus does not change.
          </p>
          <p>
            Now that we know how substitution works, let's write a function
            which given a predicate and a substitution, substitutes all
            variables in the predicate according to the substitution:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def substitute(node: Symbol, substitution: dict[Variable, Term]) -> Symbol:
    """Replace all variables in a symbol (predicate or term) with its corresponding value.

    The value can be another variable.
    """
    match node:
        case Atom() as atom:
            return atom
        case Predicate(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Predicate(name=name, args=args)
        case Function(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Function(name=name, args=args)
        case Variable() as v:
            while v in substitution:
                v = substitution[v]
            return v
              </code></pre>
            </div>
          </div>
          <p>
            Here we are taking full advantage of Python's pattern matching
            capabilities. We have 4 cases to check for. If we see an atom, we
            just return it there is nothing to do. A predicate and a function
            will both recursively call 'susbtitute' on its arguments and then
            return. If we encounter a variable, we look it up in the
            substitution dictionary. Here we use dictionary lookup in a loop as
            the dictionary might contain a chain of assignments like $$ \{X
            \leftarrow Y, Y \leftarrow f(a)\} $$ in which case we want to
            substitute \(X\) for \(f(a)\) and not simply \(Y\).
          </p>
          <p>
            Our substitution dictionary uses variables as keys so we will also
            to implement the dunder 'hash' method to make variables hashable:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Variable(Term):
    """A variable, e.g., `X` which takes on values of other terms"""

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

+    def __hash__(self):
+      return id(self)
              </code></pre>
            </div>
          </div>
          <p>Let's give the function a spin:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); c = Atom('c'); S = {X: c}
>>> P = Predicate("P", args=[X])
'P(X)'
>>> substitute(P, S)
'P(c)'
>>> X = Variable('X'); Y = Variable('Y'); Z = Variable('Z'); c = Atom('c')
>>> f = Function('f', args=[Z]);
'f(Z)'
>>> P = Predicate('P', args=[X, Y])
'P(X, Y)'
>>> S = {X: f, Y: c}
>>> substitute(P, S)
'P(f(Z), c)'
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Unification</h2>
          <p>
            The second operation we will need is unification. In simple terms,
            given two terms unification decides if one term can be transformed
            into another using an appropriate unifying substitution. A
            unification can therefore either succeed producing a subsitution as
            a result, or fail if there is no substitution which can unify the
            terms. This is a pretty general definition so let's have a look at
            some concrete examples:
          </p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Resulting substitution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(c = c\)</td>
                <td>\(\{\}\)</td>
              </tr>
              <tr>
                <td>\(X = c\)</td>
                <td>\(\{ X \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(X = Y\)</td>
                <td>\(\{ X \leftarrow Y \}\)</td>
              </tr>
              <tr>
                <td>\(f(a) = X\)</td>
                <td>\(\{ X \leftarrow f(a) \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, c) = f(g(Z), Y)\)</td>
                <td>\(\{ X \leftarrow g(Z), Y \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, Z) = f(g(Z), c)\)</td>
                <td>\(\{ X \leftarrow g(c), Y \leftarrow c \}\)</td>
              </tr>
            </tbody>
          </table>
          <p>Here are some examples of when terms do *not* unify:</p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(a = b\)</td>
                <td>Constants must be the same</td>
              </tr>
              <tr>
                <td>\(f(c) = g(c)\)</td>
                <td>Function names must match</td>
              </tr>
              <tr>
                <td>\(f(a) = f(a, b)\)</td>
                <td>Function arity must be the same</td>
              </tr>
              <tr>
                <td>\(f(X, X) = f(a, b)\)</td>
                <td>Conflicting substitutions for X</td>
              </tr>
              <tr>
                <td>\(X = f(X)\)</td>
                <td>X cannot be contained within itself</td>
              </tr>
            </tbody>
          </table>
          <p>
            Unification also naturaly extends to lists of terms (and
            predicates). For example, we can unify these 3-tuples: $$(X, f(Y),
            Z) = (b, f(c), Z)$$ by unifying each pair of terms separately and
            combining the result to get $$S = \{ X \leftarrow b, Y \leftarrow c
            \}$$ Here, we have to make sure that the partial substitutions we
            obtain from each pair are compatible. Here's an example of
            conflicting substitutions: $$(X, f(b)) = (a, f(X))$$ From the first
            pair we get \(X \leftarrow a\) while from the second one we obtain
            \(X \leftarrow b\) which are in conflict with one another. This
            means that we cannot unify these terms.
          </p>
          <p>
            Now that we have a better idea of how unification works, let's see
            how we might go about implementing it. This is arguably the most
            complicated part of our Prolog implementation so we will start slow:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case _:
          return None
              </code></pre>
            </div>
          </div>
          <p>
            Our function accepts two arguments \(x\) and \(y\) which can either
            be a single term or a list of terms. The match block will contain
            all our logic. We will start adding more cases to it slowing
            building up the whole algorithm. Let's start with atoms:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
-        case _:
-          return None
+        case (Atom(), Atom()) if x.name == y.name:
+            return {}
              </code></pre>
            </div>
          </div>
          <p>
            If we encounter two atoms with the same name we return an empty
            substitution. Otherwise we return 'None' which is going to signal
            failure to unify. Let's try it out:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> a1 = Atom('a'); a2 = Atom('a'); b = Atom('b')
>>> unify(a1, b2)
{}
>>> unify(a1, b)
None
              </code></pre>
            </div>
          </div>
          <p>So far so good. Time to add variables into the mix:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
+        case Variable(), (Atom() | Function()) as term:
+            return {x: term}
              </code></pre>
            </div>
          </div>
          <p>
            If \(x\) is a variable and \(y\) is an atom or a function, we simply
            assign \(y\) to the variable \(x\). We will do the same when \(x\)
            and \(y\) are flipped:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
            return {x: term}
+        case (Atom() | Function()) as term, Variable():
+            return {y: term}
              </code></pre>
            </div>
          </div>
          <p>Let's see what we have so far:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); c = Atom('c'); f = Function('f', args=[c])
>>> unify(X, c)
{X: 'c'}
>>> unify(f, X)
{X: 'f(c)'}
              </code></pre>
            </div>
          </div>
          <p>
            We also need a special case for when \(x\) and \(y\) are both
            variables. If \(x\) and \(y\) are equal we should simply return an
            empty substiution. Otherwise, we can assign \(y\) to \(x\) or vice
            versa, either works. For simplicity, we define variable equality as
            the builtin Python object equality. That is, variables are equal if
            they represent the same Variable instance. The alternative would be
            to compare the variable names. This approach also works fine but we
            have to be careful when creating new variables and make sure that
            the variable names are unique. Otherwise we could accidentally
            introduce an extra dependency. When using object equality we don't
            have this problem, every new Variable instance is by definition
            unique.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X1 = Variable('X'); X2 = Variable('X')
>>> X1 == X2
False
>>> X1 == X1
True
              </code></pre>
            </div>
          </div>
          <p>Now we can add the missing case to our 'unify' function:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
            return {x: term}
        case (Atom() | Function()) as term, Variable():
            return {y: term}
+        case (Variable(), Variable()):
+            if x == y:
+                return {}
+            else:
+                return {x: y}
              </code></pre>
            </div>
          </div>
          <p>
            As we said before, we do an equality check and if the variables are
            equal, we return an empty substitution. Otherwise we assign \(y\) to
            \(x\).
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); Y = Variable('Y')
>>> unify(X, Y)
{X: Y}
>>> unify(X, X)
{}
              </code></pre>
            </div>
          </div>
          <p>
            When handling functions, we need to check if the function name and
            arity are the same. If that is the case we simply recurse into the
            function arguments.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
            return {x: term}
        case (Atom() | Function()) as term, Variable():
            return {y: term}
+        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
+            return unify(x.args, y.args)
              </code></pre>
            </div>
          </div>
          <p>
            So far this wasn't so difficult, but now comes the more challenging
            part. We have to handle the case when we are trying to unify two
            lists. I will show the code first and then give an explanation
            after:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
            return {x: term}
        case (Atom() | Function()) as term, Variable():
            return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
+        case (list(), list()) if len(x) == len(y):
+            current = {}
+            for a, b in zip(x, y):
+                a = substitute(a, current)
+                b = substitute(b, current)
+ 
+                if (new := unify(a, b)) is None:
+                    return
+                current = {v: substitute(term, new) for v, term in current.items()}
+                current |= new
+            return current
              </code></pre>
            </div>
          </div>
          <p>
            Assuming the lists have the same length, we initialize \(current\)
            which will hold the current substitutions as we work our way through
            the lists. We loop over the lists. First, we substitute the current
            substitution in the terms. This basically removes all variables that
            have an assigned value from the terms. Next, we try to unify the
            terms. If they don't unify we stop there. Otherwise we take the
            result and subsitute it back into our current assignments. Then we
            simply combine the subsitutions together. Once we reach the end of
            the loop we just return \(current\) as our final subsitution.
          </p>
          <p>Anyway, let's see if it works:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> f1 = Function('f', args=[Variable('X'), Y = Variable('Y')])
'f(X, Y)'
>>> f2 = Function('f', args=[Atom('a'), Atom('b')])
'f(a, b)'
>>> unify(f1, f2)
{X: 'a', Y: 'b'}
>>> Z = Variable('Z'); a = Atom('a'); b = Atom('b')
>>> unify((Z, Z), (a, b))
None
              </code></pre>
            </div>
          </div>
          <p>
            So this is basically it for unification. The only thing that is
            missing is an occurs check - we never want to assign a term to
            variable which itself contains the variable ,e.g., \(X = f(X)\).
            This check is easy enough:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
-            return {x: term}
+            if not contains(term, x):
+                return {x: term}
        case (Atom() | Function()) as term, Variable():
-            return {y: term}
+            if not contains(term, y):
+                return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current = {v: substitute(term, new) for v, term in current.items()}
                current |= new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            The helper function 'contains' takes a term and a variable and
            returns True if the term contains variable X anywhere in it. As an
            exercise with recursion and pattern matching you can try to
            implement this function yourself ;) If you just want to see the
            code, you can have a look here:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def contains(term: Term, x: Variable):
    match term:
        case Variable() as y:
            return x == y
        case Function(args=args):
            return any(contains(arg, x) for arg in args)
        case _:
            return False
              </code></pre>
            </div>
          </div>
          <p>
            One last addition to the 'unify' function is to add support for
            predicates which will come in handy later:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
-    def unify(x: Term | list[Term], y: Term | list[Term]):
+    def unify(x: Symbol | list[Term], y: Symbol | list[Term]):
    match (x, y):
        case Atom(), Atom() if x.name == y.name:
            return {}
        case Variable(), (Atom() | Function()) as term:
            if not contains(term, x):
                return {x: term}
        case (Atom() | Function()) as term, Variable():
            if not contains(term, y):
                return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
+        case (Predicate(), Predicate()) if x.name == y.name and x.arity == y.arity:
+            return unify(x.args, y.args)
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current = substitute(current) | new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            And there we go, this was the most difficult part of the tutorial.
            Now onto the main algorithm!
          </p>
        </div>
        <div>
          <h2>Putting it all together</h2>
          <p>
            Before we get to the main algorithm though, we'll just need one
            small helper class to represent a Prolog clause. A list of clauses
            will constitute a Prolog program.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Clause:
    """A Prolog clause, e.g,

    ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
    """

    def __init__(self, head: Predicate, body: list[Predicate] = []):
        self.head = head
        self.body = body

    def __repr__(self):
        head = repr(self.head)
        if not self.body:
            return f'{head}.'
        body = ', '.join([repr(p) for p in self.body])
        return f'{head} :- {body}.'
              </code></pre>
            </div>
          </div>
          <p>
            The Clause class has a head which is a single predicate and an
            optional body which is a list of predicates. If we think of clauses
            as implications, the body would be the preconditions and the head
            would be something that must be true if the preconditions are met.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); Y = Variable('Y')
>>> P = Predicate('P', args=[X])
>>> Q = Predicate('Q', args=[Y])
>>> R = Predicate('R', args=[Y])
>>> C = Clause(head=P, body=[Q, R])
'P(X) :- Q(Y), R(Y).'
              </code></pre>
            </div>
          </div>
          <p>
            We are now ready to write the main algorithm. Before we get to
            writing the code let's first sketch the main ideas. We've got our
            Prolog program which just a list of rules and our query which for
            now just assume is a single predicate. What we need to do is take
            the query and try to unify it with the head of each of our rules. If
            the query unifies and the rule has no body, we are finished, just
            print out the substitution. If the rule does have a body, we will
            recursively try to satisfy each predicate in the body of the rule
            while maintaining all the previous subsitutions. We finish when we
            have no predicates left and we are left with the final substitution.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>

def query(rules: list[Rule], stack: list[Predicate], substitution):
  if not stack:
      yield substitution
      return

  predicate, stack = stack[0], stack[1:]
  for rule in rules:
      rule = relabel(rule)
      if (new_substitution := unify(predicate, rule.head)) is not None:
          new_stack = rule.body + stack
          new_stack = [substitute(p, new_substitution) for p in stack]
          yield from query(rules, new_stack, substitution | new_substitution)
              </code></pre>
            </div>
          </div>
          <p>
            Let's go over what happens here. We define a query function which is
            a generator. It will return all subsitutions which satisfy the query
            input. The function takes a list of rules (= Prolog program), the
            current stack which at the beginning is just the query, and the
            substitution which starts empty and we will build it up. Whenever
            the stack is empty, we know that we have proven the query and thus
            can return the substitution. If the stack is not empty, we pop the
            first predicate and try to match it (read unify) with all of the
            rules in our program. If the predicate unifies, we add this to our
            substitution, substitute evertyhing that is on the stack and
            recurse.
          </p>
          <p>
            Before run unification, we first relabel all the variables in the
            rule head and body. We need to do this because the stack might
            contain predicates with the same variables from a previous
            application of this rule but variables in separate applications
            should be treated as different.
          </p>
          <p>Just a speck of dunder magic:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
def relabel(clause: Clause):
    class Substitution(dict):
        def __missing__(self, v: Variable):
            self[v] = Variable(v.name)  # Creates new instance
            return self[v]

    substitution = Substitution()
    return Clause(
        head=substitute(clause.head, substitution),
        body=[substitute(p, substitution) for p in clause.body]
    )
              </code></pre>
            </div>
          </div>
          <p>
            The great part about Prolog is that we don't need to disinguish
            between trying to prove a fact and searching for substitutions which
            satisfy the given conditions. For Prolog is is one and the same.
          </p>
        </div>

        <div>
          <h2>Bonus: Cuts</h2>
          <p>
            When I said that Prolog is declarative I wasn't telling the whole
            truth. Prolog does have some escape hatches, to be more usable in
            practise. One such escape hatch is the cut. A cut is a predicate,
            denoted as '!' which always succeeds. What makes it special is that
            it controls the backtracking behaviour of Prolog. Once the cut
            predicate is popped off the stack, Prolog is not allowed to
            backtrack above this point. Cuts are normally used the reduce the
            number of answers Prolog will generate. This explanation can't
            really be understood without an example so here goes:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
parent(Mary, Henry).

parent_cut(X, Y) :- parent(X, Y), !.
              </code></pre>
            </div>
          </div>
        </div>
        <div class="code-sample">
          <div class="header">
            <div class="filename">core.py</div>
            <div class="commit-sha"><a href="#">34hj6k5</a></div>
          </div>
          <div class="code">
            <pre><code>

def query(rules: list[Rule], stack: list[Predicate], cuts, substitution):
    if not stack:
        yield substitution
        return

    predicate, stack = stack[0], stack[1:]
+    if isinstance(predicate, Cut):
+        cuts.add(predicate)
+        yield from query(rules, stack, cuts, substitution)
+        return
+
    for rule in rules:
        rule = relabel(rule)
        if (new_substitution := unify(predicate, rule.head)) is not None:
+            new_cuts = get_cuts(rule.body)
            new_stack = rule.body + stack
            new_stack = [substitute(p, new_substitution) for p in stack]
            yield from query(rules, new_stack, cuts | new_cuts, substitution | new_substitution)
+            for cut in new_cuts:
+                state.cuts.discard(cut)
            </code></pre>
          </div>
        </div>

        <div style="font-size: 20px; color: rgb(71, 71, 91)">
          We will build up our prolog interepreter from basic comopnents and
          operations. The buildings blocks of first order logic are terms and
          predicates. Terms can be atoms, functions and variables. Predicates
          are the equivalent to propositions from prospotional logic; they can
          be either true or false. Prolog is essentially a subset of first order
          resolution - one with a well-defined algorithm
        </div>
      </article>
    </main>
    <script src="highlight.js" type="module"></script>
    <script src="highlight-prolog.js" type="module"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        [...document.querySelectorAll(".latex")].forEach((node) => {
          katex.render(node.textContent.trim(), node, {
            throwOnError: true,
          });
        });
      });
    </script>
  </body>
</html>
