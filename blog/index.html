<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
      integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap"
      rel="stylesheet"
    />

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
      integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
      crossorigin="anonymous"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
      integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body);"
    ></script>

    <link href="highlight.css" rel="stylesheet" />
  </head>
  <body>
    <main>
      <article style="width: 800px; margin: 0 auto">
        <div>
          <h1>Prolog from scratch</h1>
          <p>
            If you've ever wondered how Prolog works under the hood, you'll find
            out that it's actually not that complicated. (And yes, this includes
            cuts as well)
          </p>
        </div>
        <div>
          <h2>Prolog crash-course</h2>
          <p>
            If you're already familiar with Prolog you can skip this section.
            This is a 2-minute Prolog 101 which will cover just the basics. If
            you're still interested afterwards, I suggest looking up some more
            in-depth tutorials afterwards.
          </p>
          <p>
            There is a Github repo to go with this tutorial which you can check
            out here. Each code sample that I give here also contains a link to
            the commit.
          </p>
          <p>
            So let's have a look what Prolog is all about and what makes it
            special. Prolog is a logical and declarative programming language.
            You are probably already familiar with declarative languages like
            SQL, in which you typically specify what you want and you let the
            language figure out how to give it to you. Logic programming
            languages are closely related to mathematical logic. In the case of
            Prolog, it is based on what is called First-Order (or Predicate)
            logic. At its core, Prolog is just database of facts expressed in
            First-Order logic which can be queried. That is, we can ask Prolog
            if something is true given some facts. Let's see some simple
            examples:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">database.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
parent(george, elizabeth).
parent(george, margaret).
parent(elizabeth, charles).
parent(philip, charles).
parent(elizabeth, edward).
parent(philip, edward).
              </code></pre>
            </div>
          </div>
          <p>
            This is a simple Prolog program - we have 6 facts describing a
            predicate called 'parent'. The arguments are Prolog constants (in
            the language of logic, atoms). Anything that starts with a lowercase
            letter is treated as a constant in Prolog.
          </p>
          <p>Now we can take this program and ask questions about it:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
?- parent(george, elizabeth).
- true.

?- parent(margaret, elizabeth).
- false.
              </code></pre>
            </div>
          </div>
          <p>
            First, we asked if 'george' is a parent of 'elizabeth' and Prolog
            returned 'true'. Next, we asked whether 'parent(margaret,
            elizabeth)' and Prolog returned 'false'. To answer these queries,
            Prolog simply checks if the query exists in the program. This on its
            own is not that useful, so let's what else we can do:
          </p>
          <pre><code>
            ?- parent(george, X).
            - X = elizabeth.
            - X = margaret.

            ?- parent(X, Y).
            - X = george, Y = elizabeth.
            - X = george, Y = margaret.
            - X = elizabeth, Y = charles.
            - X = george, Y = charles.
            - X = elizabeth, Y = edward.
            - X = philip, Y = edward.
          </code></pre>
          <p>
            So what happened here? Rather than asking Prolog if some fact is in
            the database, we can ask for all results that match our query by
            using variables. (Prolog considers anything that starts with an
            upercase letter to be a variable) When Prolog sees that the query
            has a variable, it tries to find all assignments that satisfy the
            query.
          </p>
          <p>
            For now, we've only worked with simple facts, but Prolog also
            includes 'conditionals', in the language of logic, clauses. Let's
            use a clause to implement an 'ancestor' predicate:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
              </code></pre>
            </div>
          </div>
          <p>
            A Prolog clause is basically an implication. The above reads as: IF
            (parent(X, Z) AND ancestor(Z, Y)) THEN ancestor(X, Y). Basically,
            you have to read it backwards. Let's have a look:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
?- ancestor(george, elizabeth).
- true.

?- ancestor(george, charles).
- true.
              </code></pre>
            </div>
          </div>
          <p>We can of course ask for all ancestors of a person, e.g.:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
?- ancestor(X, charles).
- X = elizabeth.
- X = philip.
- X = george.
- X = edward.
              </code></pre>
            </div>
          </div>
          <p>
            And here lies the power of Prolog. Just by merely defining the
            'ancestor' predicate, we can not only ask if someone is someone
            else's ancestor but we can also ask Prolog to generate all ancestors
            according to the rules that we gave it. The only difference is that
            we use variables instead of constants, which is pretty neat. Imagine
            trying to implement this in another language.
          </p>
          <p>
            Prolog being closely related to First-Order logic has support for
            functions as well. Functions in Prolog, as in First-Order logic, are
            purely syntactic in nature (also called uninterpreted functions).
            They are used to build structure and to form compound terms from
            simple terms. In fact, Prolog does not have any built-in
            data-structures. We'll show one example of functions which is to
            define lists:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
is_list(list()).
is_list(list(Head, Tail)) :- is_list(Tail).
              </code></pre>
            </div>
          </div>
          <p>
            This definition basically says that an empty list (denoted as the
            argument-less function `list()`) is a list. Then, we recursively
            define a list as any list function with a head and a tail which is
            again a list. This kind of a linked list is similar to how lists are
            used in Lisp.
          </p>
          <p>We can also define operations on lists such as the length:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
length(list(), 0).
length(list(Head, Tail), NN) :- length(Tail, N), increment(N, NN).
              </code></pre>
            </div>
          </div>
          <p>
            (We assume that we have previously defined the 'increment' predicate
            which just increments by one)
          </p>
          <p>
            This concludes our Prolog crash-course. To summarize, in Prolog you
            define predicates which can either be simple facts like
            'parent(george, elizabeth)' or clauses which can be thought of as
            logical implications. When given a query, Prolog will try to find a
            variable assignment that satisfies all clauses.
          </p>
        </div>
        <!-- <div>
          <h2>How Prolog actually works</h2>
          <p>
            Prolog is essentially just a restricted form of First-Order
            resolution. The resolution algorithm allows us to answers questions
            like given a set of clauses S, and a formula q, does S => q? This is
            in general NP-Hard, but Prolog imposes a restriction that all
            clauses are Horn clauses, that is, the head contains only a single
            predicate. This makes it possible to systemcatically search
            resulting tree and the complexity becomes linear.
          </p>
        </div> -->
        <div>
          <h2>Getting our hands dirty</h2>
          <p>
            This is the part where we actually start implementing our own
            verions of Prolog. If you skipped the tutorial, you can start
            reading from here.
          </p>
          <p>
            We'll be using Python version >=3.10 since it includes structural
            pattern matching which will come in handy as we shall see later.
          </p>
          <p>
            Let's start by defining the basic elements of First-Order logic
            which are used by Prolog:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Term(Symbol):
    """Base class for atoms & variables"""


class Atom(Term):
    """A constant term, e.g., `c`"""

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class Function(Term):
    """A function term, e.g., `f(c)`"""

    def __init__(self, name, args: list[Term]):
        self.name = name
        self.arity = len(args)
        self.args = args

    def __repr__(self):
        args = ', '.join([repr(arg) for arg in self.args])
        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <p>
            We added the dunder 'repr' to have a nice print output. Let's try it
            out:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Atom('c')
'c'
>>> Function('f', args=[Atom('a')])
'f(a)'
>>> Function('f', args=[Atom('a'), Function('g', args=[Atom('b')])])
'f(a, g(b))'
              </code></pre>
            </div>
          </div>
          <p>Let's also add variables..</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
...

+class Variable(Term):
+    """A variable, e.g., `X` which takes on values of other terms"""
+
+    def __init__(self, name):
+        self.name = name
+
+    def __repr__(self):
+        return self.name
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Variable('X')
'X'
>>> Function('f', args=[Variable('X')])
'f(X)'
              </code></pre>
            </div>
          </div>
          <p>..and predicates</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
+class Symbol:
+    """Base class for terms and predicates"""

-class Term:
+class Term(Symbol):
    """Base class for atoms, functions & variables"""
...
+class Predicate(Symbol):
+    """A predicate, e.g., `P(X, f(Y))`. Predicates can be assigned truth values."""
+
+    def __init__(self, name, args: list[Term]):
+        self.name = name
+        self.arity = len(args)
+        self.args = args
+
+    def __repr__(self):
+        args = ', '.join([repr(arg) for arg in self.args])
+        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Predicate('P', args=[Variable('X'), Atom('x')])
'P(X, c)'
>>> Predicate('P', args=[Function('f', args=[Variable('X')])])
'P(f(X))'
              </code></pre>
            </div>
          </div>
          <p>
            We will now define some operations that can act on these objects. As
            we will see, the core of Prolog relies on just two operations -
            substitution and unification.
          </p>
        </div>
        <div>
          <h2>Substitution</h2>
          <p>
            Substitution in Prolog works the same way as in First-Order logic.
            When we have term, we might want to replace all occurences of a
            variable with the value of that variable. This is called a
            substitution. Let's see a simple example:
          </p>
          <div class="latex">S = \{ X \leftarrow c, Y \leftarrow f(b) \}</div>
          <div class="latex">P(X, Y, Z)</div>
          <p>
            Here, \(S\) is a set of variable assignments and \(P\) is our
            predicate in which we want to substitute varibles from \(S\). This
            is the result of the substitution:
          </p>
          <div class="latex">P(c, f(b), Z)</div>
          <p>
            \(X\) and \(Y\) are present in \(S\) and thus get substituted. \(Z\)
            is not a member of \(S\) and thus does not change.
          </p>
          <p>
            Now that we know how substitution works, let's write a function
            which given a predicate and a substitution, substitutes all
            variables in the predicate according to the substitution:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def substitute(node: Symbol, substitution: dict[Variable, Term]) -> Symbol:
    """Replace all variables in a symbol (predicate or term) with its corresponding value.

    The value can be another variable.
    """
    match node:
        case Atom() as atom:
            return atom
        case Predicate(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Predicate(name=name, args=args)
        case Function(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Function(name=name, args=args)
        case Variable() as v:
            while v in substitution:
                v = substitution[v]
            return v
              </code></pre>
            </div>
          </div>
          <p>
            Here we are taking full advantage of Python's pattern matching
            capabilities. We have 4 cases to check for. If we see an atom, we
            just return it there is nothing to do. A predicate and a function
            will both recursively call 'susbtitute' on its arguments and then
            return. If we encounter a variable, we look it up in the
            substitution dictionary. Here we use dictionary lookup in a loop as
            the dictionary might contain a chain of assignments like $$ \{X
            \leftarrow Y, Y \leftarrow f(a)\} $$ in which case we want to
            substitute \(X\) for \(f(a)\) and not simply \(Y\).
          </p>
          <p>
            Our substitution dictionary uses variables as keys so we will also
            to implement the dunder 'hash' method to make variables hashable:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Variable(Term):
    """A variable, e.g., `X` which takes on values of other terms"""

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

+    def __hash__(self):
+      return id(self)
              </code></pre>
            </div>
          </div>
          <p>Let's give the function a spin:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); c = Atom('c'); S = {X: c}
>>> P = Predicate("P", args=[X])
'P(X)'
>>> substitute(P, S)
'P(c)'
>>> X = Variable('X'); Y = Variable('Y'); Z = Variable('Z'); c = Atom('c')
>>> f = Function('f', args=[Z]);
'f(Z)'
>>> P = Predicate('P', args=[X, Y])
'P(X, Y)'
>>> S = {X: f, Y: c}
>>> substitute(P, S)
'P(f(Z), c)'
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Unification</h2>
          <p>
            The second operation we will need is unification. In simple terms,
            given two terms unification decides if one term can be transformed
            into another using an appropriate unifying substitution. A
            unification can therefore either succeed producing a subsitution as
            a result, or fail if there is no substitution which can unify the
            terms. This is a pretty general definition so let's have a look at
            some concrete examples:
          </p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Resulting substitution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(c = c\)</td>
                <td>\(\{\}\)</td>
              </tr>
              <tr>
                <td>\(X = c\)</td>
                <td>\(\{ X \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(X = Y\)</td>
                <td>\(\{ X \leftarrow Y \}\)</td>
              </tr>
              <tr>
                <td>\(f(a) = X\)</td>
                <td>\(\{ X \leftarrow f(a) \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, c) = f(g(Z), Y)\)</td>
                <td>\(\{ X \leftarrow g(Z), Y \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, Z) = f(g(Z), c)\)</td>
                <td>\(\{ X \leftarrow g(c), Y \leftarrow c \}\)</td>
              </tr>
            </tbody>
          </table>
          <p>
            Here are some examples of when it is not possible unify two terms:
          </p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(a = b\)</td>
                <td>Constants must be the same</td>
              </tr>
              <tr>
                <td>\(f(c) = g(c)\)</td>
                <td>Function names must match</td>
              </tr>
              <tr>
                <td>\(f(a) = f(a, b)\)</td>
                <td>Function arity must be the same</td>
              </tr>
              <tr>
                <td>\(f(X, X) = f(a, b)\)</td>
                <td>Conflicting substitutions for X</td>
              </tr>
              <tr>
                <td>\(X = f(X)\)</td>
                <td>X cannot be contained within itself</td>
              </tr>
            </tbody>
          </table>
          <p>
            Unification is used by Prolog to figure out which clauses it can
            apply and which it cannot. Consider this example:
          </p>
          <p>
            Now that we have a good idea of what unification does, let's see how
            we might implement it ourselves:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Symbol | list[Term], y: Symbol | list[Term]):
    match (x, y):
        case (Atom(), Atom()) if x.name == y.name:
            return {}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (Predicate(), Predicate()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (Variable(), Variable()):
            if x == y:
                return {}
            else:
                return {x: y}
        case (Variable(), (Atom() | Function()) as term):
            if not contains(term, x):
                return {x: term}
        case ((Atom() | Function()) as term, Variable()):
            if not contains(term, y):
                return {y: term}
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current = substitute(current) | new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            This looks complicated, but this is actually the most complicated
            part of our Prolog implementaion. The algorithm is comparatively
            much simpler so hang in there. We are again taking advantage of
            Python's pattern matching to make the code clearer. (The fact that
            we rely on pattern matching is not that surprising given that Prolog
            is essentially just a unification machine and Python's pattern
            matching is a simpler form of unification) If we see two atoms, the
            names must match, ottherwise we fail. For functions and predicates,
            we enforce matching names and arity and recurs to the arguments. The
            interesting part comes with variables. If one side is a variable we
            assign it to the other. If the variables are equal, we don't need to
            do anything. If we are dealing with two lists (e.g. from multiple
            predicate arguments), we unify the first element which gives a
            partial substitution. We use it to substitute the rest of the lists
            and compute unification for the following elements. Rinse and
            repeat.
          </p>
          <p>
            In the code, we reference a helper function called 'contains(term,
            X)' which returns True if the term contains variable X anywhere in
            it. As an exercise with recursion and pattern matching you can try
            to implement this function yourself ;) Otherwise, you can have a
            look here:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def contains(term: Term, x: Variable):
    match term:
        case Variable() as y:
            return x == y
        case Function(args=args):
            return any(contains(arg, x) for arg in args)
        case _:
            return False
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Putting it all together</h2>
          <p>
            Before we get to the core of the algorithm, we'll just one need one
            helper class to represent a prolog clause
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Clause:
    """A Prolog clause, e.g,
    
    connected(A, C) :- connected(A, B), connected(B, C).
    """

    def __init__(self, head: Predicate, body: list[Predicate] = []):
        self.head = head
        self.body = body

    def __repr__(self):
        head = repr(self.head)
        if not self.body:
            return f'{head}.'
        body = ', '.join([repr(p) for p in self.body])
        return f'{head} :- {body}.'
              </code></pre>
            </div>
          </div>
          <p>
            The Clause class has a head which is a single predicate and an
            optional body - a list of predicates. We just add a friendly repr so
            that we can print it as well.
          </p>
          <p>
            We are now ready to write the main algorithm. Before we get to
            writing the code let's first sketch the main ideas. We've got our
            Prolog program which just a list of rules and our query which for
            now just assume is a single predicate. What we need to do is take
            the query and try to unify it with the head of each of our rules. If
            the query unifies and the rule has no body, we are finished, just
            print out the substitution. If the rule does have a body, we will
            recursively try to satisfy each predicate in the body of the rule
            while maintaining all the previous subsitutions. We finish when we
            have no predicates left and we are left with the final substitution.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>

def query(rules: list[Rule], stack: list[Predicate], substitution):
  if not stack:
      yield substitution
      return

  predicate, stack = stack[0], stack[1:]
  for rule in rules:
      rule = relabel(rule)
      if (new_substitution := unify(predicate, rule.head)) is not None:
          new_stack = rule.body + stack
          new_stack = [substitute(p, new_substitution) for p in stack]
          yield from query(rules, new_stack, substitution | new_substitution)
              </code></pre>
            </div>
          </div>
          <p>
            Let's go over what happens here. We define a query function which is
            a generator. It will return all subsitutions which satisfy the query
            input. The function takes a list of rules (= Prolog program), the
            current stack which at the beginning is just the query, and the
            substitution which starts empty and we will build it up. Whenever
            the stack is empty, we know that we have proven the query and thus
            can return the substitution. If the stack is not empty, we pop the
            first predicate and try to match it (read unify) with all of the
            rules in our program. If the predicate unifies, we add this to our
            substitution, substitute evertyhing that is on the stack and
            recurse.
          </p>
          <p>
            The great part about Prolog is that we don't need to disinguish
            between trying to prove a fact and searching for substitutions which
            satisfy the given conditions. For Prolog is is one and the same.
          </p>
        </div>

        <div>
          <h2>Bonus: Cuts</h2>
          <p>
            When I said that Prolog is declarative I wasn't telling the whole
            truth. Prolog does have some escape hatches, to be more usable in
            practise. One such escape hatch is the cut. A cut is a predicate,
            denoted as '!' which always succeeds. What makes it special is that
            it controls the backtracking behaviour of Prolog. Once the cut
            predicate is popped off the stack, Prolog is not allowed to
            backtrack above this point. Cuts are normally used the reduce the
            number of answers Prolog will generate. This explanation can't
            really be understood without an example so here goes:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
parent(Mary, Henry).

parent_cut(X, Y) :- parent(X, Y), !.
              </code></pre>
            </div>
          </div>
        </div>

        <div style="font-size: 20px; color: rgb(71, 71, 91)">
          We will build up our prolog interepreter from basic comopnents and
          operations. The buildings blocks of first order logic are terms and
          predicates. Terms can be atoms, functions and variables. Predicates
          are the equivalent to propositions from prospotional logic; they can
          be either true or false. Prolog is essentially a subset of first order
          resolution - one with a well-defined algorithm
        </div>
      </article>
    </main>
    <script src="highlight.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        [...document.querySelectorAll(".latex")].forEach((node) => {
          katex.render(node.textContent.trim(), node, {
            throwOnError: true,
          });
        });
      });
    </script>
  </body>
</html>
