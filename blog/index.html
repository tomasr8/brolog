<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
      integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.3/full/pyodide.js"></script>

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
      integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
      crossorigin="anonymous"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js"
      integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body);"
    ></script>

    <link href="highlight.css" rel="stylesheet" />
  </head>
  <body>
    <main>
      <article style="width: 800px; margin: 0 auto">
        <div>
          <h1>Prolog from scratch with Python</h1>
          <p>
            We're going to implement a simple Prolog interepreter from scratch
            using Python. Prolog might look daunting from the outside but we'll
            see that under the hood it's actually not that complicated.
          </p>
          <p>
            There is a Github repo to go with this tutorial. Each code sample in
            this tutorial also has a commit hash in the top right corner which
            lets you view the full code covered so far.
          </p>
        </div>
        <div>
          <h2>Prolog crash-course</h2>
          <p>
            If you're already familiar with Prolog, you can safely skip this
            section. If this is your first encounter with Prolog or logic
            programming in general, I've written a (very) brief introduction so
            I'd encourage you to look up more in-depth resources afterwards.
          </p>
          <p>
            So let's have a look what Prolog is all about and what makes it
            different from move conventional programming languages. Prolog is a
            declarative programming language. You are probably already familiar
            with declarative languages like SQL. In those languages you
            typically specify what you want and you let the language figure out
            how to get the result for you rather than providing a setup-by-step
            instructions like in more imperative languages.
          </p>
          <p>
            Being declarative doesn'make Prolog that different, what's more
            interesting is that it is a logic programming language. Logic
            programming languages have close ties to mathematical logic. Prolog
            itself is based on First-Order (also called Predicate) logic. You
            can think of Prolog as essentially a theorem prover for First-Order
            logic. You give it a set of facts and a logical formula and ask does
            this formula logically follow from my these facts?
          </p>
          <p>Just to illustrate what I mean, here are two logic formulas:</p>
          <p>
            $$ \begin{align*} &philosopher(scorates) \\ &philosopher(plato) \\
            &philosopher(aristotle) \\ &philosopher(Y) \rightarrow human(Y) \\
            &human(X) \rightarrow mortal(X) \end{align*} $$
          </p>
          <p>
            That is, \(p\) implies \(q\) and \(p\) is true. We want to know
            whether we can prove \(q\) from these two facts. And we can see that
            in fact \(q\) follows from those two formulas. In this case it
            wasn't that hard to figure out, but imagine we have dozens or
            hundreds of formulas. Luckily there is an algorithm which can solve
            this kind of problem called resolution which is basically modus
            ponens on streoids and this is what Prolog uses under the hood.
            (modus ponens)
          </p>
          <p>Let's see how we can write this in Prolog:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">simple.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
philosopher(scorates).
philosopher(plato).
philosopher(aristotle).

human(X) :- philosopher(X).
mortal(Y) :- human(Y).
              </code></pre>
            </div>
          </div>
          <p>
            The first line is essentially identical. Formulas in Prolog must be
            terminated using a dot (<code class="inline">.</code>). The second
            line represents the implication \(p \Rightarrow q\). Notice however,
            that the order is swapped in Prolog. That is \(p \Rightarrow q\) is
            written as <code class="inline">q :- p</code>.
          </p>
          <p>
            Prolog allows only a restricted form of an implication clauses ...
          </p>
          <p>We can now ask Prolog if it can derive \(q\):</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">simple.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
?- q.
true.
              </code></pre>
            </div>
          </div>
          <p>
            Don't worry about the ?- part, it just means we want Prolog to prove
            the formula that comes after it. The answer we got is
            <code class="inline">true</code> meaning Prolog was able to prove
            \(q\) as expected.
          </p>
          <p>
            This is cool, but we can do more. Remember that Prolog understands
            First-Order logic. This means that we can use predicates and
            variables as well:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">simple.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
p(dog).
p(cat).
q(X) :- p(X).
              </code></pre>
            </div>
          </div>
          <p>
            Here <code class="inline">p</code> and
            <code class="inline">q</code> are predicates which take one
            argument. In Prolog, identifiers that start with a lowercase letter
            like <code class="inline">dog</code> and
            <code class="inline">cat</code> are treat as constants - there is no
            need to use quotes. Identifiers starting with an uppercase letter
            like <code class="inline">X</code>
            are treated as variables.
          </p>
          <p>Let's see what Prolog can prove about this program:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">simple.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
?- p(dog).
true.

?- p(elephant).
false.

?- q(dog).
true.
              </code></pre>
            </div>
          </div>
          <p>
            The first result is not at all surprising,
            <code class="inline">p(dog)</code> is one of the formulas we already
            had. Prolog predictably fails to prove the second formula since we
            don't have <code class="inline">p(elephant)</code> as an atomic
            formula and there is no way to derive it. We can prove the last
            query by starting with <code class="inline">p(dog)</code> and
            applying <code class="inline">q(X) :- p(X)</code> and substituting
            <code class="inline">dog</code> for <code class="inline">X</code> to
            get <code class="inline">q(dog)</code>.
          </p>
          <p>
            So far so good. Let's see what happens when our query contains a
            variable:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">simple.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
?- p(X).
X = dog.
X = cat.

?- q(X).
X = dog.
X = cat.
              </code></pre>
            </div>
          </div>
          <p>
            When we use a variable in the query, Prolog will give us all
            assignments for the variable which make the formula provable. For
            example, the results of the second query are telling us that
            <code class="inline">q(dog)</code> and
            <code class="inline">q(cat)</code> are both provable.
          </p>
          <p>
            This makes Prolog incredibly powerful because if we can convert our
            problem to Prolog, we can not only ask if something is true, but we
            can flip the question and have Prolog generate all facts that are
            true instead.
          </p>
          <p>Let's see a less contrived example:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">parents.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code prolog">
              <pre><code>
parent(george, elizabeth).
parent(george, margaret).
parent(elizabeth, charles).
parent(philip, charles).
parent(elizabeth, edward).
parent(charles, harry).

ancestor(X, Y) :- parent(X, Y).
ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
              </code></pre>
            </div>
          </div>
          <p>
            In this example we first define a
            <code class="inline">parent</code> predicate.
            <code class="inline">parent(george, elizabeth)</code> means that
            <code class="inline">george</code> is the parent of
            <code class="inline">elizabeth</code>. We now define a new
            predicate, <code class="inline">ancestor(X, Y)</code> which is true
            if <code class="inline">X</code> is an ancestor (parent,
            grandparent, ..) of <code class="inline">Y</code>.
          </p>
          <p>
            In a typical Prolog style, it is defined recursively. The base case
            says that a parent is also an ancestor. The recursive case says that
            an ancestor of <code class="inline">Y</code> must be a parent of
            someone else (<code class="inline">Z</code>) who is an ancestor of
            <code class="inline">Y</code>. This step essentially allows us to
            decompose the ancestor into a series of parents.
          </p>
          <p>
            Here's an analogous function written in Python for a comparison:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">parents.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def ancestor(x, y):
    if parent(x, y):
        return True
    for z in people:
      if parent(x, z) and ancestor(z, y):
          return True
              </code></pre>
            </div>
          </div>
          <p>
            Once you've digested the code, we can take the Prolog program and
            make some queries:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- ancestor(george, elizabeth).
true.

?- ancestor(george, harry).
true.
              </code></pre>
            </div>
          </div>
          <p>
            The first query can be proven from the application of the first rule
            since <code class="inline">parent(george, elizabeth)</code> is
            already given. To prove the second query, Prolog applies the second
            rule twice to get from <code class="inline">george</code> to
            <code class="inline">elizabeth</code> to
            <code class="inline">charles</code> and finally to
            <code class="inline">harry</code>.
          </p>
          <p>We can show the computation using this animation:</p>
          <p>Continuing, we can ask for all ancestors of a specific person:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- ancestor(X, charles).
X = elizabeth.
X = philip.
X = george.
X = edward.
              </code></pre>
            </div>
          </div>
          <p>
            Pretty neat. Prolog can again figure out on its own what
            <code class="inline">X</code> to make the query true. Pretty neat.
            Imagine trying to implement this in another language.
          </p>
          <p>And to finish off, let's see all ancestor pairs:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Prolog REPL&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- ancestor(X, Y).
X = george, Y = elizabeth
.
.
.
              </code></pre>
            </div>
          </div>
          <p>
            There's one last thing I'd like to show in this Prolog 101 and that
            is functions. Functions in Prolog, as in First-Order logic, are
            purely syntactic in nature (also called uninterpreted functions).
            They are used to build structure and to form compound terms from
            simple terms. In fact, Prolog does not have any built-in data
            structures to speak of. Although it doesn't really need them since
            we can implement everything we might want with just functions. The
            classical example is a linked list:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
X = c(1, c(2, c(3, c()))).
              </code></pre>
            </div>
          </div>
          <p>
            We've taken a function <code class="inline">c</code> (like
            <code class="inline">cons</code> in Lisp) and we define a list as
            follows. <code class="inline">c()</code> is an empty list.
            <code class="inline">c(H, T)</code>
            is a list where <code class="inline">H</code> is the first element
            (called head) and <code class="inline">T</code> is the rest of the
            list (called tail).
          </p>
          <p>
            If we wanted to translate
            <code class="inline">c(1, c(2, c(3, c())))</code> it would simply be
            <code class="inline">[1,2,3]</code>. (That is also the case in some
            Prolog implementations like SWI Prolog where one can write list as
            <code class="inline">[1,2,3]</code> but it is merely a syntactic
            sugar)
          </p>
          <p>
            Now that we have a definition of a list, we can even write a Prolog
            to recognize lists.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
list(c()).
list(c(Head, Tail)) :- list(Tail).
              </code></pre>
            </div>
          </div>
          <p>
            Prolog essentially allows us to desctructure the argument passed to
            list and do different things. This is very similar to Python's own
            pattern matching, just more powerful.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- list(c(1, c())).
true.

?- list(c(1, c(, c()))).
true.

?- list(d(1, d())).
false.
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
class c:
    def __init__(self, head: Any = None, tail: Self|None = None):
        self.head = head
        self.tail = tail

def is_list(x):
    match x:
        case c(head=None, tail=None):
            return True
        case c(head=_, tail=tail):
            return is_list(x)

is_list(c(1, c()))
is_list(c(1, c(2, c())))
              </code></pre>
            </div>
          </div>
          <p>
            Using our new lists, we can easily define predicates that operate on
            them:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
last(c(Last, c()), Last).
last(c(Head, Tail), Last) :- last(Tail, Last).
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code prolog">
              <pre><code>
?- last(c(1, c()), L).
L = 1.

?- X = c(1, c(2, c())), last(X, L).
L = 2.

?- last(c()).
false.
              </code></pre>
            </div>
          </div>
          <p>Python equivalent:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
def last(x: list):
    match x:
        case (head,):
            return head
        case (head, *tail):
            return last(tail)
              </code></pre>
            </div>
          </div>
          <p>
            This concludes our Prolog crash-course. To summarize, in Prolog you
            can define a set of clauses on which you can then make inference
            such as asking if a formula is a logical consequence of the given
            clauses. If you use variables in the query, Prolog will find the
            variable assignments which make the query provable (or fail).
          </p>
        </div>
        <!-- <div>
          <h2>Connection to First-Order logic</h2>
          <p>
            Prolog is essentially just a restricted form of First-Order
            resolution. The resolution algorithm allows us to answers questions
            like given a set of clauses S, and a formula q, does S => q? This is
            in general NP-Hard, but Prolog imposes a restriction that all
            clauses are Horn clauses, that is, the head contains only a single
            predicate. This makes it possible to systemcatically search
            resulting tree and the complexity becomes linear.
          </p>
        </div> -->
        <div>
          <h2>Getting our hands dirty</h2>
          <p>
            This is the part where we actually start implementing our own
            verions of Prolog. If you skipped the Prolog crash-course, you can
            start reading from here.
          </p>
          <p>
            We'll be using Python version >=3.10 since it includes structural
            pattern matching which will make the implementation much easier.
          </p>
          <p>
            Let's start by defining the basic elements of First-Order logic
            which we are going to need to represent Prolog clauses:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Term:
    """Base class for constants & functions"""


class Constant(Term):
    """A constant term, e.g., `c`"""

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class Function(Term):
    """A function term, e.g., `f(c)`"""

    def __init__(self, name, args: list[Term]):
        self.name = name
        self.arity = len(args)
        self.args = args

    def __repr__(self):
        args = ', '.join([repr(arg) for arg in self.args])
        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <p>
            We added the dunder <code class="inline">repr()</code> to have a
            nice print output. Let's try it out:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Constant('c')
'c'
>>> Function('f', args=[Constant('a')])
'f(a)'
>>> Function('f', args=[Constant('a'), Function('g', args=[Constant('b')])])
'f(a, g(b))'
              </code></pre>
            </div>
          </div>
          <p>Let's also add variables:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Term:
-    """Base class for constants & functions"""
+    """Base class for constants, functions & variables"""

...

+class Variable(Term):
+    """A variable, e.g., `X` which takes on values of other terms"""
+
+    def __init__(self, name):
+        self.name = name
+
+    def __repr__(self):
+        return self.name
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Variable('X')
'X'
>>> Function('f', args=[Variable('X')])
'f(X)'
              </code></pre>
            </div>
          </div>
          <p>..and predicates</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
+class Symbol:
+    """Base class for terms and predicates"""

-class Term:
+class Term(Symbol):
    """Base class for constants, functions & variables"""

...

+class Predicate(Symbol):
+    """A predicate, e.g., `P(X, f(Y))`."""
+
+    def __init__(self, name, args: list[Term]):
+        self.name = name
+        self.arity = len(args)
+        self.args = args
+
+    def __repr__(self):
+        args = ', '.join([repr(arg) for arg in self.args])
+        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Predicate('P', args=[Variable('X'), Constant('c')])
'P(X, c)'
>>> Predicate('P', args=[Function('f', args=[Variable('X')])])
'P(f(X))'
              </code></pre>
            </div>
          </div>
          <p>
            We will now define some operations that can act on these objects. As
            we will see, the core of Prolog relies on just two operations -
            substitution and unification.
          </p>
        </div>
        <div>
          <h2>Substitution</h2>
          <p>
            Substitution in Prolog works the same way as in First-Order logic.
            When we have term, we might want to replace all occurences of a
            variable with the value of that variable. This is called a
            substitution. Let's see a simple example:
          </p>
          <div class="latex">S = \{ X \leftarrow c, Y \leftarrow f(b) \}</div>
          <div class="latex">P(X, Y, Z)</div>
          <p>
            Here, \(S\) is a set of variable assignments and \(P\) is our
            predicate in which we want to substitute varibles from \(S\). This
            is the result of the substitution:
          </p>
          <div class="latex">P(c, f(b), Z)</div>
          <p>
            \(X\) and \(Y\) are present in \(S\) and thus get substituted. \(Z\)
            is not a member of \(S\) and thus does not change.
          </p>
          <p>
            Now that we know how substitution works, let's write a function
            which given a predicate and a substitution, substitutes all
            variables in the predicate according to the substitution:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def substitute(node: Symbol, substitution: dict[Variable, Term]) -> Symbol:
    """Replace all variables in a symbol (predicate or term) with its corresponding value.

    The value can be another variable.
    """
    match node:
        case Constant() as atom:
            return atom
        case Predicate(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Predicate(name=name, args=args)
        case Function(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Function(name=name, args=args)
        case Variable() as v:
            while v in substitution:
                v = substitution[v]
            return v
              </code></pre>
            </div>
          </div>
          <p>
            Here we are taking full advantage of Python's pattern matching
            capabilities. We have 4 cases to check for. If we see an atom, we
            just return it there is nothing to do. A predicate and a function
            will both recursively call 'susbtitute' on its arguments and then
            return. If we encounter a variable, we look it up in the
            substitution dictionary. Here we use dictionary lookup in a loop as
            the dictionary might contain a chain of assignments like $$ \{X
            \leftarrow Y, Y \leftarrow f(a)\} $$ in which case we want to
            substitute \(X\) for \(f(a)\) and not simply \(Y\).
          </p>
          <p>
            Our substitution dictionary uses variables as keys so we will also
            to implement the dunder 'hash' method to make variables hashable:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Variable(Term):
    """A variable, e.g., `X` which takes on values of other terms"""

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

+    def __hash__(self):
+      return id(self)
              </code></pre>
            </div>
          </div>
          <p>Let's give the function a spin:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); c = Constant('c'); S = {X: c}
>>> P = Predicate("P", args=[X])
'P(X)'
>>> substitute(P, S)
'P(c)'
>>> X = Variable('X'); Y = Variable('Y'); Z = Variable('Z'); c = Constant('c')
>>> f = Function('f', args=[Z]);
'f(Z)'
>>> P = Predicate('P', args=[X, Y])
'P(X, Y)'
>>> S = {X: f, Y: c}
>>> substitute(P, S)
'P(f(Z), c)'
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Unification</h2>
          <p>
            The second operation we will need is unification. In simple terms,
            given two terms unification decides if one term can be transformed
            into another using an appropriate unifying substitution. A
            unification can therefore either succeed producing a subsitution as
            a result, or fail if there is no substitution which can unify the
            terms. This is a pretty general definition so let's have a look at
            some concrete examples:
          </p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Resulting substitution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(c = c\)</td>
                <td>\(\{\}\)</td>
              </tr>
              <tr>
                <td>\(X = c\)</td>
                <td>\(\{ X \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(X = Y\)</td>
                <td>\(\{ X \leftarrow Y \}\)</td>
              </tr>
              <tr>
                <td>\(f(a) = X\)</td>
                <td>\(\{ X \leftarrow f(a) \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, c) = f(g(Z), Y)\)</td>
                <td>\(\{ X \leftarrow g(Z), Y \leftarrow c \}\)</td>
              </tr>
              <tr>
                <td>\(f(X, Z) = f(g(Z), c)\)</td>
                <td>\(\{ X \leftarrow g(c), Y \leftarrow c \}\)</td>
              </tr>
            </tbody>
          </table>
          <p>Here are some examples of when terms do *not* unify:</p>
          <table>
            <thead>
              <tr>
                <th>Input</th>
                <th>Note</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(a = b\)</td>
                <td>Constants must be the same</td>
              </tr>
              <tr>
                <td>\(f(c) = g(c)\)</td>
                <td>Function names must match</td>
              </tr>
              <tr>
                <td>\(f(a) = f(a, b)\)</td>
                <td>Function arity must be the same</td>
              </tr>
              <tr>
                <td>\(f(X, X) = f(a, b)\)</td>
                <td>Conflicting substitutions for X</td>
              </tr>
              <tr>
                <td>\(X = f(X)\)</td>
                <td>X cannot be contained within itself</td>
              </tr>
            </tbody>
          </table>
          <p>
            Unification also naturaly extends to lists of terms (and
            predicates). For example, we can unify these 3-tuples: $$(X, f(Y),
            Z) = (b, f(c), Z)$$ by unifying each pair of terms separately and
            combining the result to get $$S = \{ X \leftarrow b, Y \leftarrow c
            \}$$ Here, we have to make sure that the partial substitutions we
            obtain from each pair are compatible. Here's an example of
            conflicting substitutions: $$(X, f(b)) = (a, f(X))$$ From the first
            pair we get \(X \leftarrow a\) while from the second one we obtain
            \(X \leftarrow b\) which are in conflict with one another. This
            means that we cannot unify these terms.
          </p>
          <p>
            Now that we have a better idea of how unification works, let's see
            how we might go about implementing it. This is arguably the most
            complicated part of our Prolog implementation so we will start slow:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case _:
          return None
              </code></pre>
            </div>
          </div>
          <p>
            Our function accepts two arguments \(x\) and \(y\) which can either
            be a single term or a list of terms. The match block will contain
            all our logic. We will start adding more cases to it slowing
            building up the whole algorithm. Let's start with atoms:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
-        case _:
-          return None
+        case (Constant(), Constant()) if x.name == y.name:
+            return {}
              </code></pre>
            </div>
          </div>
          <p>
            If we encounter two atoms with the same name we return an empty
            substitution. Otherwise we return 'None' which is going to signal
            failure to unify. Let's try it out:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> a1 = Constant('a'); a2 = Constant('a'); b = Constant('b')
>>> unify(a1, b2)
{}
>>> unify(a1, b)
None
              </code></pre>
            </div>
          </div>
          <p>So far so good. Time to add variables into the mix:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
+        case Variable(), (Constant() | Function()) as term:
+            return {x: term}
              </code></pre>
            </div>
          </div>
          <p>
            If \(x\) is a variable and \(y\) is an atom or a function, we simply
            assign \(y\) to the variable \(x\). We will do the same when \(x\)
            and \(y\) are flipped:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
            return {x: term}
+        case (Constant() | Function()) as term, Variable():
+            return {y: term}
              </code></pre>
            </div>
          </div>
          <p>Let's see what we have so far:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); c = Constant('c'); f = Function('f', args=[c])
>>> unify(X, c)
{X: 'c'}
>>> unify(f, X)
{X: 'f(c)'}
              </code></pre>
            </div>
          </div>
          <p>
            We also need a special case for when \(x\) and \(y\) are both
            variables. If \(x\) and \(y\) are equal we should simply return an
            empty substiution. Otherwise, we can assign \(y\) to \(x\) or vice
            versa, either works. For simplicity, we define variable equality as
            the builtin Python object equality. That is, variables are equal if
            they represent the same Variable instance. The alternative would be
            to compare the variable names. This approach also works fine but we
            have to be careful when creating new variables and make sure that
            the variable names are unique. Otherwise we could accidentally
            introduce an extra dependency. When using object equality we don't
            have this problem, every new Variable instance is by definition
            unique.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;Python REPL&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X1 = Variable('X'); X2 = Variable('X')
>>> X1 == X2
False
>>> X1 == X1
True
              </code></pre>
            </div>
          </div>
          <p>Now we can add the missing case to our 'unify' function:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
            return {x: term}
        case (Constant() | Function()) as term, Variable():
            return {y: term}
+        case (Variable(), Variable()):
+            if x == y:
+                return {}
+            else:
+                return {x: y}
              </code></pre>
            </div>
          </div>
          <p>
            As we said before, we do an equality check and if the variables are
            equal, we return an empty substitution. Otherwise we assign \(y\) to
            \(x\).
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); Y = Variable('Y')
>>> unify(X, Y)
{X: Y}
>>> unify(X, X)
{}
              </code></pre>
            </div>
          </div>
          <p>
            When handling functions, we need to check if the function name and
            arity are the same. If that is the case we simply recurse into the
            function arguments.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
            return {x: term}
        case (Constant() | Function()) as term, Variable():
            return {y: term}
+        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
+            return unify(x.args, y.args)
              </code></pre>
            </div>
          </div>
          <p>
            So far this wasn't so difficult, but now comes the more challenging
            part. We have to handle the case when we are trying to unify two
            lists. I will show the code first and then give an explanation
            after:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
            return {x: term}
        case (Constant() | Function()) as term, Variable():
            return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
+        case (list(), list()) if len(x) == len(y):
+            current = {}
+            for a, b in zip(x, y):
+                a = substitute(a, current)
+                b = substitute(b, current)
+ 
+                if (new := unify(a, b)) is None:
+                    return
+                current = {v: substitute(term, new) for v, term in current.items()}
+                current |= new
+            return current
              </code></pre>
            </div>
          </div>
          <p>
            Assuming the lists have the same length, we initialize \(current\)
            which will hold the current substitutions as we work our way through
            the lists. We loop over the lists. First, we substitute the current
            substitution in the terms. This basically removes all variables that
            have an assigned value from the terms. Next, we try to unify the
            terms. If they don't unify we stop there. Otherwise we take the
            result and subsitute it back into our current assignments. Then we
            simply combine the subsitutions together. Once we reach the end of
            the loop we just return \(current\) as our final subsitution.
          </p>
          <p>Anyway, let's see if it works:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> f1 = Function('f', args=[Variable('X'), Y = Variable('Y')])
'f(X, Y)'
>>> f2 = Function('f', args=[Constant('a'), Constant('b')])
'f(a, b)'
>>> unify(f1, f2)
{X: 'a', Y: 'b'}
>>> Z = Variable('Z'); a = Constant('a'); b = Constant('b')
>>> unify((Z, Z), (a, b))
None
              </code></pre>
            </div>
          </div>
          <p>
            So this is basically it for unification. The only thing that is
            missing is an occurs check - we never want to assign a term to
            variable which itself contains the variable ,e.g., \(X = f(X)\).
            This check is easy enough:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Term | list[Term], y: Term | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
-            return {x: term}
+            if not contains(term, x):
+                return {x: term}
        case (Constant() | Function()) as term, Variable():
-            return {y: term}
+            if not contains(term, y):
+                return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current = {v: substitute(term, new) for v, term in current.items()}
                current |= new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            The helper function 'contains' takes a term and a variable and
            returns True if the term contains variable X anywhere in it. As an
            exercise with recursion and pattern matching you can try to
            implement this function yourself ;) If you just want to see the
            code, you can have a look here:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def contains(term: Term, x: Variable):
    match term:
        case Variable() as y:
            return x == y
        case Function(args=args):
            return any(contains(arg, x) for arg in args)
        case _:
            return False
              </code></pre>
            </div>
          </div>
          <p>
            One last addition to the 'unify' function is to add support for
            predicates which will come in handy later:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
-    def unify(x: Term | list[Term], y: Term | list[Term]):
+    def unify(x: Symbol | list[Term], y: Symbol | list[Term]):
    match (x, y):
        case Constant(), Constant() if x.name == y.name:
            return {}
        case Variable(), (Constant() | Function()) as term:
            if not contains(term, x):
                return {x: term}
        case (Constant() | Function()) as term, Variable():
            if not contains(term, y):
                return {y: term}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
+        case (Predicate(), Predicate()) if x.name == y.name and x.arity == y.arity:
+            return unify(x.args, y.args)
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current = substitute(current) | new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            And there we go, this was the most difficult part of the tutorial.
            Now onto the main algorithm!
          </p>
        </div>
        <div>
          <h2>Putting it all together</h2>
          <p>
            Before we get to the main algorithm though, we'll just need one
            small helper class to represent a Prolog clause. A Prolog program
            will be represented simply as a list of clauses.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Clause:
    """A Prolog clause, e.g,

    ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
    """

    def __init__(self, head: Predicate, body: list[Predicate] = []):
        self.head = head
        self.body = body

    def __repr__(self):
        head = repr(self.head)
        if not self.body:
            return f'{head}.'
        body = ', '.join([repr(p) for p in self.body])
        return f'{head} :- {body}.'
              </code></pre>
            </div>
          </div>
          <p>
            The Clause class has a head which is a single predicate and an
            optional body which is a list of predicates. If we think of clauses
            as implications, the body would be the preconditions and the head
            would be something that must be true if the preconditions are met.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); Y = Variable('Y')
>>> P = Predicate('P', args=[X])
>>> Q = Predicate('Q', args=[Y])
>>> R = Predicate('R', args=[Y])
>>> C = Clause(head=P, body=[Q, R])
'P(X) :- Q(Y), R(Y).'
              </code></pre>
            </div>
          </div>
          <p>
            Let's first see how Prolog actually proves a query: (SLD tree
            example)
          </p>
          <p>
            We are now ready to write the main algorithm. Before we get to
            writing the code let's first sketch the main ideas. We've got our
            Prolog program which just a list of rules and our query which for
            now just assume is a single predicate. What we need to do is take
            the query and try to unify it with the head of each of our rules. If
            the query unifies and the rule has no body, we are finished, just
            print out the substitution. If the rule does have a body, we will
            recursively try to satisfy each predicate in the body of the rule
            while maintaining all the previous subsitutions. We finish when we
            have no predicates left and we are left with the final substitution.
          </p>
          <p>
            1) if the query is empty we have proven, return substitution 2) we
            pop the first predicate from the query. 3) for each clause in
            program do Relabel clause variables to avoid clashes 4) if clause
            head unifies with with predicate and subsitituion S 5) push clause
            body into the query 6) substitute the whole query with S 7)
            prove(query)
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def prove(program: list[Clause], query: list[Predicate], substitution):
    if not query:
        yield substitution
        return
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def prove(program: list[Clause], query: list[Predicate], substitution):
    if not query:
        yield substitution
        return
+
+    predicate, query = query[0], query[1:]
+    for clause in program:
+        # ...
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def prove(program: list[Clause], query: list[Predicate], substitution):
    if not query:
        yield substitution
        return
    
    predicate, query = query[0], query[1:]
    for clause in program:
+        if (clause_substitution := unify(predicate, clause.head)) is not None:
+            new_query = clause.body + query
+            new_query = [substitute(p, new_substitution) for p in query]
+            yield from prove(program, new_stack, substitution | clause_substitution)
              </code></pre>
            </div>
          </div>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def prove(program: list[Clause], query: list[Predicate], substitution):
    if not query:
        yield substitution
        return
    
    predicate, query = query[0], query[1:]
    for clause in program:
        clause = relabel(clause)
        if (new_substitution := unify(predicate, clause.head)) is not None:
            new_query = clause.body + query
            new_query = [substitute(p, new_substitution) for p in query]
            yield from prove(program, new_stack, substitution | new_substitution)
              </code></pre>
            </div>
          </div>
          <p>
            Let's see what happens on our toy program. ancestor(george,
            elizabeth)
          </p>
          <p>
            Let's go over what happens here. We define a query function which is
            a generator. It will return all subsitutions which satisfy the query
            input. The function takes a list of rules (= Prolog program), the
            current stack which at the beginning is just the query, and the
            substitution which starts empty and we will build it up. Whenever
            the stack is empty, we know that we have proven the query and thus
            can return the substitution. If the stack is not empty, we pop the
            first predicate and try to match it (read unify) with all of the
            rules in our program. If the predicate unifies, we add this to our
            substitution, substitute evertyhing that is on the stack and
            recurse.
          </p>
          <p>
            Before run unification, we first relabel all the variables in the
            rule head and body. We need to do this because the stack might
            contain predicates with the same variables from a previous
            application of this rule but variables in separate applications
            should be treated as different.
          </p>
          <p>Just a speck of dunder magic:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
def relabel(clause: Clause):
    class Substitution(dict):
        def __missing__(self, v: Variable):
            self[v] = Variable(v.name)  # Creates new instance
            return self[v]

    substitution = Substitution()
    return Clause(
        head=substitute(clause.head, substitution),
        body=[substitute(p, substitution) for p in clause.body]
    )
              </code></pre>
            </div>
          </div>
          <p>
            The great part about Prolog is that we don't need to disinguish
            between trying to prove a fact and searching for substitutions which
            satisfy the given conditions. For Prolog is is one and the same.
          </p>
        </div>

        <div>
          <h2>Bonus: Cuts</h2>
          <p>
            When I said that Prolog is declarative I wasn't telling the whole
            truth. Prolog does have some escape hatches, to be more usable in
            practise. One such escape hatch is the cut. A cut is a predicate,
            denoted as '!' which always succeeds. What makes it special is that
            it controls the backtracking behaviour of Prolog. Once the cut
            predicate is popped off the stack, Prolog is not allowed to
            backtrack above this point. Cuts are normally used the reduce the
            number of answers Prolog will generate. This explanation can't
            really be understood without an example so here goes:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
parent(Mary, Henry).

parent_cut(X, Y) :- parent(X, Y), !.
              </code></pre>
            </div>
          </div>
        </div>
        <div class="code-sample">
          <div class="header">
            <div class="filename">core.py</div>
            <div class="commit-sha"><a href="#">34hj6k5</a></div>
          </div>
          <div class="code">
            <pre><code>

def query(rules: list[Rule], stack: list[Predicate], cuts, substitution):
    if not stack:
        yield substitution
        return

    predicate, stack = stack[0], stack[1:]
+    if isinstance(predicate, Cut):
+        cuts.add(predicate)
+        yield from query(rules, stack, cuts, substitution)
+        return
+
    for rule in rules:
        rule = relabel(rule)
        if (new_substitution := unify(predicate, rule.head)) is not None:
+            new_cuts = get_cuts(rule.body)
            new_stack = rule.body + stack
            new_stack = [substitute(p, new_substitution) for p in stack]
            yield from query(rules, new_stack, cuts | new_cuts, substitution | new_substitution)
+            for cut in new_cuts:
+                state.cuts.discard(cut)
            </code></pre>
          </div>
        </div>
        <div>
          <h2>REPL</h2>
          <p>
            <textarea id="python-input"></textarea>
            <button id="run-python" type="button">Run</button>
          </p>
        </div>
      </article>
    </main>
    <script src="highlight.js" type="module"></script>
    <script src="highlight-prolog.js" type="module"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        [...document.querySelectorAll(".latex")].forEach((node) => {
          katex.render(node.textContent.trim(), node, {
            throwOnError: true,
          });
        });
      });
    </script>
    <script>
      async function main() {
        console.log("HERE")
        let pyodide = await loadPyodide();

        document.getElementById("run-python").addEventListener("click", () => {
          const text = document.getElementById("python-input").value
          console.log(pyodide.runPython(text))
        })
        // Pyodide is now ready to use...
        console.log(
          pyodide.runPython(`
          import sys
          sys.version
        `)
        );
      }
      main();
    </script>
  </body>
</html>
