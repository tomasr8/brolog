<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title></title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css"
      integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI"
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap"
      rel="stylesheet"
    />

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js"
      integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t"
      crossorigin="anonymous"
    ></script>

    <link href="highlight.css" rel="stylesheet" />
  </head>
  <body>
    <main>
      <article style="width: 800px; margin: 0 auto">
        <!-- <div style="font-family: 'Noto Serif', serif"> -->
        <div>
          <h1>Prolog from scratch</h1>
          <p>
            If you've ever wondered how Prolog works under the hood, you'll find
            out that it's actually not that complicated.
          </p>
        </div>
        <div>
          <h2>Prolog crash-course</h2>
          <p>
            If you're already familiar with Prolog you can skip this section. If
            you don't know anything about Prolog, this is a 2-minute tutorial
            which will cover the basics. If you're still interested afterwards,
            I suggest looking some more in-depth tutorials.
          </p>
          <p>
            Here, I want to quickly showcase the power of Prolog and what makes
            it special compraed to other languages. Prolog, like SQL, .. is a
            declarative language. At its core it is a database of facts, a sort
            of a knowledge base, which can be queried. Consider this simple
            Prolog program:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">database.pl</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
parent(george,elizabeth).
parent(george, margaret).
parent(elizabeth,charles).
parent(philip,charles).
parent(elizabeth,edward).
parent(philip,edward).
parent(charles,william).
parent(diana,william).
parent(charles,harry).
parent(diana,harry).
              </code></pre>
            </div>
          </div>
          <p>
            In this example, we have 3 facts. Each fact in prolog is a predicate
            with a name and arguments. Our city predicate is simply establishing
            what is a city. Prolog operates on symbols such as 'goerge' and
            'elizabeth' here, there's no need for quotes or anything like that.
            Anyhting that starts with a lowercase letter is treated as a
            constant.
          </p>
          <p>
            Now we can query this 'database' and ask if something is a city: -?
            city(Munich). - false. ?- city(Prague). - true.
          </p>
          <pre><code>
            ?- parent(george, elizabeth).
            - true.

            ?- parent(margaret, elizabeth).
            - false.
          </code></pre>
          <p>
            And Prolog responds accoringly. This is admittedly not very useful.
            All that that Prolog has to do is search the database and check if
            the fact exists in the database or not.
          </p>
          <pre><code>
            ?- parent(george, X).
            - X = elizabeth.

            ?- parent(X, Y).
            - X = george, Y = elizabeth.
            - ...
            - ...
          </code></pre>
          <p>
            But now comes the part which makes prolog incredibly powerful. -?
            city(X). - Prague. - Berlin. - Warsaw.
          </p>
          <p>
            So what happened here? Rather than asking Prolog is something is in
            the database, we can ask it for all the results that match our
            query. Here, we used a variable X, which signals to Prolog to find
            all matching facts.
          </p>
          <p>
            Ok, so we can use Variables and Prolog will give us all answers that
            satisfy the query. That still does not make it very useful. However,
            Prolog also allows to specify rules. A rule looks like this:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
parent(Mary, Henry).
parent(Henry, Harold).

ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
              </code></pre>
            </div>
          </div>
          <p>
            A rule in Prolog is basically a special kind of implication a,b =>
            c. You can see it if you read the rule backwards. Basically, this is
            saying that if parent(X, Z), ancestor(Z, Y) for some X,Y and Z, then
            ancestor(X, Y).
          </p>
          <p>
            So once we have this, we can of course ask Prolog: ?- ancestor(Mary,
            Henry). - true.
          </p>
          <p>
            But we can also ask for all ancestors ?- ancestor(Mary, X). - X =
            Henry
          </p>
          <p>
            The power of Prolog is that by defining the rules, we can not only
            check if something is true, but we can prolog to generate answers
            which satisfy our conditions just by putting in variables, which is
            pretty neat. Imagine trying to implement this in another language.
          </p>
          <p>
            Prolog is actually closesly related to First-order logic and such
            supports functions as well. Functions in Prolog, as in First-Order
            logic are purely syntactic in nature. They are used to build
            structure and to form compound terms from simple terms since Prolog
            does not have any built-in data-structures. A natural use for
            functions is to define lists.
          </p>
          <pre><code>
            is_list(list()).
            is_list(list(Head, Tail)) :- is_list(Tail).
          </code></pre>
          <p>
            This definition basically says that an empty list (denoted as
            `list()`) is a list. Then it recusrively defines a list as anything
            which is the list function with a head and a tail which is again a
            list. This kind is essentially the same a lists in Lisp.
          </p>
          <p>
            Using this list we can define operations on lists. For example, we
            ask Prolog for its length:
          </p>
          <pre><code>
            length(list(), 0).
            length(list(Head, Tail), NN) :- length(Tail, N), increment(N, NN).
          </code></pre>
        </div>
        <div>
          <h2>How Prolog actually works</h2>
          <p>
            Prolog is essentially just a restricted form of First-Order
            resolution. The resolution algorithm allows us to answers questions
            like given a set of clauses S, and a formula q, does S => q? This is
            in general NP-Hard, but Prolog imposes a restriction that all
            clauses are Horn clauses, that is, the head contains only a single
            predicate. This makes it possible to systemcatically search
            resulting tree and the complexity becomes linear.
          </p>
        </div>
        <div>
          <h2>Getting our hands dirty</h2>
          <p>
            Let's start by implementing the building blocks that will allows us
            represent elements of First-Order logic.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Term(Symbol):
    """Base class for atoms & variables"""


class Atom(Term):
    """A constant term, e.g., `c`"""

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class Function(Term):
    """A function term, e.g., `f(c)`"""

    def __init__(self, name, args: list[Term]):
        self.name = name
        self.arity = len(args)
        self.args = args

    def __repr__(self):
        args = ', '.join([repr(arg) for arg in self.args])
        return f'{self.name}({args})'
              </code></pre>
            </div>
          </div>
          <p>
            Let's try it out: Atom('c') -> c Function('f', args=[Atom('a'),
            Function('g', args=[Atom('b')])]) -> f(a, g(b))
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> Atom('c')
'c'
>>> Function('f', args=[Atom('a')])
'f(a)'
>>> Function('f', args=[Atom('a'), Function('g', args=[Atom('b')])])
'f(a, g(b))'
              </code></pre>
            </div>
          </div>
          <p>Let's also add variables:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
...

+class Variable(Term):
+    """A variable, e.g., `X` which takes on values of other terms"""
+
+    def __init__(self, name):
+        self.name = name
+
+    def __str__(self):
+        return self.name
              </code></pre>
            </div>
          </div>
          <p>
            As we will see the core of Prolog relies on just a handful of
            operations on these objects. Most notably substitution and
            unification.
          </p>
        </div>
        <div>
          <h2>Substitution</h2>
          <p>
            In Prolog, and in Predicate logic, variables represent other terms -
            atoms, functions, and other variables. Image we have this
            substitution:
          </p>
          <div class="latex">\{ X \rightarrow c, Y \rightarrow f(b) \}</div>
          <div class="latex">P(X, Y)</div>
          <p>The result would be:</p>
          <div class="latex">P(c, f(b))</div>
          <p>
            Let's write a function which given a predicate and a substitution,
            substitutes all variables in the predicate according to the
            substitution.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def substitute(node: Symbol, substitution: dict[Variable, Term]) -> Symbol:
    """Replace all variables in a symbol (predicate or term) with its corresponding value.

    The value can be another variable.
    """
    match node:
        case Atom() as atom:
            return atom
        case Predicate(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Predicate(name=name, args=args)
        case Function(name=name, args=args):
            args = [substitute(arg, substitution) for arg in args]
            return Function(name=name, args=args)
        case Variable() as v:
            while v in substitution:
                v = substitution[v]
            return v
              </code></pre>
            </div>
          </div>
          <p>
            Here we are taking full advantage of Python's pattern matching. We
            basically have 4 cases to check for. If the we have an atom, we just
            return as there is nothing to do. A predicate and a a function will
            subsitutute its arguments. If we encounter a variable we check if it
            exists in the subsitution. Here we need a while loop as there could
            be chain of variables e.g. X -> Y -> f(a)
          </p>
          <p>
            In this function we are using our Variable instances as keys in a
            dictionary, s we just need to make them hashable to make it work.
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Variable(Term):
    """A variable, e.g., `X` which takes on values of other terms"""

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

+    def __hash__(self):
+      return id(self)
              </code></pre>
            </div>
          </div>
          <p>Let's try it out:</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
>>> X = Variable('X'); P = Predicate("P", args=[X]), c = Atom('c')
>>> S = {X: c}
>>> substitute(P, S)
'P(c)'
>>> X = Variable('X'); Y = Variable('Y'); Z = Variable('Z')
>>> f = Function('f', args=[Z]); c = Atom('c')
>>> P = Predicate('P', args=[X, Y])
'P(X, Y)'
>>> S = {X: f, Y: c}
>>> substitute(P, S)
'P(f(Z), c)'
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Unification</h2>
          <p>
            The second operation we will need is unification. In simple terms,
            unification decides if one predicate can be transformed into another
            using a substitution. This transformation has a precise mathematical
            definition, but you can get a feel for it from these examples:
          </p>
          <div class="latex">P(X), P(c), \{ X \rightarrow c \}</div>
          <div class="latex">P(X), P(Y), \{ X \rightarrow Y \}</div>
          <div class="latex">P(f(a)), P(X), \{ X \rightarrow f(a) \}</div>
          <div class="latex">
            P(X, Y), P(c, X), \{ X \rightarrow c, Y \rightarrow c \}
          </div>
          <p>All of these succefully unify, whereas these examples do not:</p>
          <div class="latex">
            P(X), Q(c) // \text{Predicate names must match}
          </div>
          <div class="latex">
            P(X), P(X, Y) \text{// Predicate arity must match}
          </div>
          <div class="latex">
            P(X, X), P(a, b) \text{// Conflicting substitutions for X}
          </div>
          <div class="latex">
            P(X), P(f(X)), \text{// X cannot be contained in itself}
          </div>
          <p>
            As we've seen a unification can either succeed with and gives a
            substitution or it can fail. Prolog uses unification to decide which
            rules it can match. Let's see how we might implement it ourselves:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def unify(x: Symbol | list[Term], y: Symbol | list[Term]):
    match (x, y):
        case (Atom(), Atom()) if x.name == y.name:
            return {}
        case (Function(), Function()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (Predicate(), Predicate()) if x.name == y.name and x.arity == y.arity:
            return unify(x.args, y.args)
        case (Variable(), Variable()):
            if x == y:
                return {}
            else:
                return {x: y}
        case (Variable(), (Atom() | Function()) as term):
            if not contains(term, x):
                return {x: term}
        case ((Atom() | Function()) as term, Variable()):
            if not contains(term, y):
                return {y: term}
        case (list(), list()) if len(x) == len(y):
            current = {}
            for a, b in zip(x, y):
                a = substitute(a, current)
                b = substitute(b, current)

                if (new := unify(a, b)) is None:
                    return
                current |= new
            return current
              </code></pre>
            </div>
          </div>
          <p>
            This looks complicated, but this is actually the most complicated
            part of our Prolog implementaion. The algorithm is comparatively
            much simpler so hang in there. We are again taking advantage of
            Python's pattern matching to make the code clearer. (The fact that
            we rely on pattern matching is not that surprising given that Prolog
            is essentially just a unification machine and Python's pattern
            matching is a simpler form of unification) If we see two atoms, the
            names must match, ottherwise we fail. For functions and predicates,
            we enforce matching names and arity and recurs to the arguments. The
            interesting part comes with variables. If one side is a variable we
            assign it to the other. If the variables are equal, we don't need to
            do anything. If we are dealing with two lists (e.g. from multiple
            predicate arguments), we unify the first element which gives a
            partial substitution. We use it to substitute the rest of the lists
            and compute unification for the following elements. Rinse and
            repeat.
          </p>
          <p>
            In the code, we reference a helper function called 'contains(term,
            X)' which returns True if the term contains variable X anywhere in
            it. As an exercise with recursion and pattern matching you can try
            to implement this function yourself ;) Otherwise, you can have a
            look here:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
def contains(term: Term, x: Variable):
    match term:
        case Variable() as y:
            return x == y
        case Function(args=args):
            return any(contains(arg, x) for arg in args)
        case _:
            return False
              </code></pre>
            </div>
          </div>
        </div>
        <div>
          <h2>Putting it all together</h2>
          <p>
            Before we get to the core of the algorithm,
            we'll just one need one helper class to represent a prolog clause
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>
class Clause:
    """A Prolog clause, e.g,
    
    connected(A, C) :- connected(A, B), connected(B, C).
    """

    def __init__(self, head: Predicate, body: list[Predicate] = []):
        self.head = head
        self.body = body

    def __repr__(self):
        head = repr(self.head)
        if not self.body:
            return f'{head}.'
        body = ', '.join([repr(p) for p in self.body])
        return f'{head} :- {body}.'
              </code></pre>
            </div>
          </div>
          <p>
            The Clause class has a head which is a single predicate and an optional body - a list of predicates.
            We just add a friendly repr so that we can print it as well.
          </p>
          <p>We are now ready to write the main algorithm.</p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">core.py</div>
              <div class="commit-sha"><a href="#">34hj6k5</a></div>
            </div>
            <div class="code">
              <pre><code>

def query(rules: list[Rule], stack: list[Predicate], substitution):
  if not stack:
      yield substitution
      return

  predicate, stack = stack[0], stack[1:]
  for rule in rules:
      rule = relabel(rule)
      if (new_substitution := unify(predicate, rule.head)) is not None:
          new_stack = rule.body + stack
          new_stack = [substitute(p, new_substitution) for p in stack]
          yield from query(rules, new_stack, substitution | new_substitution)
              </code></pre>
            </div>
          </div>
          <p>
            Let's go over what happens here. We define a query function which is
            a generator. It will return all subsitutions which satisfy the query
            input. The function takes a list of rules (= Prolog program), the
            current stack which at the beginning is just the query, and the
            substitution which starts empty and we will build it up. Whenever
            the stack is empty, we know that we have proven the query and thus
            can return the substitution. If the stack is not empty, we pop the
            first predicate and try to match it (read unify) with all of the
            rules in our program. If the predicate unifies, we add this to our
            substitution, substitute evertyhing that is on the stack and
            recurse.
          </p>
          <p>
            The great part about Prolog is that we don't need to disinguish
            between trying to prove a fact and searching for substitutions which
            satisfy the given conditions. For Prolog is is one and the same.
          </p>
        </div>

        <div>
          <h2>Bonus: Cuts</h2>
          <p>
            When I said that Prolog is declarative I wasn't telling the whole
            truth. Prolog does have some escape hatches, to be more usable in
            practise. One such escape hatch is the cut. A cut is a predicate,
            denoted as '!' which always succeeds. What makes it special is that
            it controls the backtracking behaviour of Prolog. Once the cut
            predicate is popped off the stack, Prolog is not allowed to
            backtrack above this point. Cuts are normally used the reduce the
            number of answers Prolog will generate. This explanation can't
            really be understood without an example so here goes:
          </p>
          <div class="code-sample">
            <div class="header">
              <div class="filename">&lt;stdin&gt;</div>
            </div>
            <div class="code">
              <pre><code>
parent(Mary, Henry).

parent_cut(X, Y) :- parent(X, Y), !.
              </code></pre>
            </div>
          </div>
        </div>

        <div style="font-size: 20px; color: rgb(71, 71, 91)">
          We will build up our prolog interepreter from basic comopnents and
          operations. The buildings blocks of first order logic are terms and
          predicates. Terms can be atoms, functions and variables. Predicates
          are the equivalent to propositions from prospotional logic; they can
          be either true or false. Prolog is essentially a subset of first order
          resolution - one with a well-defined algorithm
        </div>
      </article>
    </main>
    <script src="highlight.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        [...document.querySelectorAll(".latex")].forEach((node) => {
          katex.render(node.textContent.trim(), node, {
            throwOnError: true,
          });
        });
        // const elem = document.getElementById("latex");
        // katex.render("c = \\pm\\sqrt{a^2 + b^2}", elem, {
        //   throwOnError: false,
        // });
      });
    </script>
  </body>
</html>
